;;-*-Lisp-*-
(in-package goal)
(bundles "JUN.DGO")
(require "engine/geometry/path.gc")
(require "engine/common-obs/process-taskable.gc")
(require "engine/target/logic-target.gc")
(require "engine/target/sidekick.gc")
(declare-type fisher-fish process-drawable)


(deftype fisher-bank (basic)
  (
    (width       meters)
    (net-radius  meters)
    (net-max-vel  float) ; per second
    (net-accel    float) ; per second
    (net-decel    float) ; per second
    (fish-vel     float)
    (max-caught   int32)
    (max-missed   int32)
  )
)

(define *fisher-bank*
  (new 'static 'fisher-bank
    :width       (meters   3.3) ;vanilla:   3.3
    :net-radius  (meters   0.7) ;vanilla:   0.7
    :net-max-vel           2.0  ;vanilla:   2.0
    :net-accel            28.0  ;vanilla:  28.0
    :net-decel            15.0  ;vanilla:  15.0
    :fish-vel              1.85 ;vanilla:   1.85
    :max-caught          200    ;vanilla: 200
    :max-missed           20    ;vanilla:  20
  )
)


(defpartgroup group-fish-deadly
  :id 177
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 828) (sp-item 2013))
)

(defpart 828
  :init-specs (
    (:texture (bigpuff effects))
    (:num 0.5 0.5)
    (:y (meters 0.2))
    (:scale-x (meters 0.5) (meters 0.5))
    (:scale-y :copy scale-x)
    (:r 128.0 128.0)
    (:b 128.0 128.0)
    (:a 0.0)
    (:vel-x (meters -0.0033333334) (meters 0.006666667))
    (:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.53333336)
    (:timer (seconds 2))
    (:flags (bit2 bit14))
    (:next-time (seconds 0.035) (seconds 0.177))
    (:next-launcher 829)
  )
)

(defpart 829
  :init-specs (
    (:fade-a -0.21333334)
  )
)

(defpart 2013
  :init-specs (
    (:texture (lakedrop effects))
    (:num 0.1 1.0)
    (:x (meters -0.7) (meters 0.5))
    (:z (meters -0.1) (meters 0.2))
    (:scale-x (meters 0.05) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:fade-a -0.42666668)
    (:accel-y (meters 0.00033333333))
    (:timer (seconds 0.5))
    (:flags (bit2 bit3 bit14))
  )
)


(defpartgroup group-fish-normal
  :id 178
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 2001))
)

(defpart 2001
  :init-specs (
    (:texture (lakedrop effects))
    (:num 0.1 1.0)
    (:x (meters -0.4) (meters 0.5))
    (:z (meters -0.25) (meters 0.5))
    (:scale-x (meters 0.05) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:fade-a -0.42666668)
    (:accel-y (meters 0.00033333333))
    (:timer (seconds 0.5))
    (:flags (bit2 bit3 bit14))
  )
)


(defpartgroup group-fish-big
  :id 179
  :duration (seconds 0.017)
  :linger-duration (seconds 4)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 830) (sp-item 831))
)

(defpart 831
  :init-specs (
    (:texture (starflash effects))
    (:num 2.0)
    (:scale-x (meters 5) (meters 1))
    (:scale-y :copy scale-x)
    (:r 32.0 64.0)
    (:g 128.0 128.0)
    (:a 16.0)
    (:fade-a -1.6)
    (:timer (seconds 0.085))
    (:flags (bit2 bit3))
  )
)

(defpart 830
  :init-specs (
    (:texture (flare effects))
    (:num 16.0)
    (:scale-x (meters 2) (meters 2))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.25) (meters 0.5))
    (:r 32.0 64.0)
    (:g 128.0 128.0)
    (:b 0.0)
    (:a 0.0)
    (:scalevel-x (meters 0.009765625))
    (:rotvel-z (degrees -0.3) (degrees 0.6))
    (:scalevel-y (meters 0.009765625))
    (:fade-a 1.2)
    (:timer (seconds 0.5))
    (:flags (bit2 bit3))
    (:func 'sparticle-track-root)
    (:next-time (seconds 0.035) (seconds 0.03))
    (:next-launcher 832)
  )
)

(defpart 832
  :init-specs (
    (:fade-a -0.8)
  )
)


(deftype fisher-wave-data (structure)
  (
    (length         time-frame)
    (post-margin    time-frame)
    (vel                 float)
    (swing-min      time-frame)
    (swing-max      time-frame)
    (period         time-frame)
    (fish-vel            float)
    (big-chance         float)
    (deadly-chance      float)
    ;;[ADD-FISH-TYPE] (<FISH-TYPE>-chance float)
  )
  :allow-misaligned
)

(define *fisher-hardmode-cheat-length* 9)
(define *fisher-hardmode-cheat*
  (new 'static 'array int 9
    (pad-buttons left)
    (pad-buttons left)
    (pad-buttons right)
    (pad-buttons right)
    (pad-buttons left)
    (pad-buttons left)
    (pad-buttons right)
    (pad-buttons right)
    (pad-buttons x)
  )
)

(define *fisher-max-pity* 4)
(define *fisher-hardmode-idx* 5)

; Mostly for rendering lol
; Real wave counts, actual lengths are +2 from these
(define *fisher-wave-counts*
  (new 'static 'array int 6
     7 ; Pity 0
     7 ; Pity 1
     7 ; Pity 2
     7 ; Pity 3
    12 ; Pity 4
    10 ; Hard Mode
  )
)

(define *fisher-waves*
  (new 'static 'boxed-array :type (inline-array fisher-wave-data)
    ; Pity 0
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 0.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.5
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 8)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.6
        :big-chance 0.25
        :deadly-chance 0.375)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.45)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.5)
        :fish-vel 1.9
        :big-chance 0.1
        :deadly-chance 0.81)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.35)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 1
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 1)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.4
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 9)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.5
        :big-chance 0.25
        :deadly-chance 0.3)
      (new 'static 'fisher-wave-data
        :length (seconds 18)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.527)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data
        :length (seconds 18)
        :post-margin (seconds 2.0)
        :vel 2.41
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.48)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data
        :length (seconds 14)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.58)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.72)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.43)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 2
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 1.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 12)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.8)
        :fish-vel 1.4
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.8)
        :fish-vel 1.5
        :big-chance 0.25
        :deadly-chance 0.225)
      (new 'static 'fisher-wave-data
        :length (seconds 21)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.61)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data
        :length (seconds 21)
        :post-margin (seconds 2.0)
        :vel 1.83
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.56)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data
        :length (seconds 14)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.66)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.54)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.515)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 3
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 2)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.4
        :big-chance 0.25
        :deadly-chance 0.15)
      (new 'static 'fisher-wave-data
        :length (seconds 23)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.4
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 23)
        :post-margin (seconds 2.0)
        :vel 1.25
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.65)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.75)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.45)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 4
    (new 'static 'inline-array fisher-wave-data 14
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 2.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.25
        :deadly-chance 0.15)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.7
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data)
    )

    ; Hard Mode
    (new 'static 'inline-array fisher-wave-data 12
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 2.0
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 5)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 2.0
        :big-chance 0.25
        :deadly-chance 0.5625)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.3)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.81)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.4
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.25)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.15)
        :fish-vel 2.2
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.4
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.25)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.18)
      (new 'static 'fisher-wave-data
        :length (seconds 31535998)
        :post-margin (seconds 2.0)
        :vel 1.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.15)
        :fish-vel 2.2
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data)
    )
  )
)


(deftype fisher-perm (entity-perm)
  (
    (accum    float :overlay-at (-> user-float 0))
    (div      uint8 :overlay-at (-> user-uint8 4))
    (attempts uint8 :overlay-at (-> user-uint8 5))
    (pity      int8 :overlay-at (-> user-int8  6))
  )
)

(deftype fisher (process-taskable)
  (
    (paddle-end      vector 2 :inline)
    (paddle-pos      vector :inline)
    (paddle          float)
    (paddle-vel      float)
    (spawner         float)
    (spawner-last    float)
    (spawn-time      time-frame)
    (turn-time       time-frame)
    (swing-time      time-frame)
    (wave-time       time-frame)
    (wave            int32)
    (caught          int32)
    (missed          int32)
    (pity            int32)
    (max-caught      int)
    (max-missed      int)
    (start-time      time-frame)
    (ambient-big-one time-frame)
    (ambient-steady  time-frame)
    (ambient-sagging time-frame)
    (ambient-almost  time-frame)
    (cheat-progress      int32)
    (hard            symbol)
    (training        symbol)
    (wave-data       fisher-wave-data :inline)
  )

  (:states
    fisher-done
    fisher-playing
  )
)

(deftype fisher-fish (process-drawable)
  (
    (dir       vector :inline)
    (offset    float) ; offset in river, [0.0, 1.0]
    (pos       float) ; position on river path
    (vel       float) ; velocity along river path
    (fish-type basic)
    (size      meters)
  )
  (:states
    fisher-fish-caught
    fisher-fish-die
    fisher-fish-fall
  )
)


(defskelgroup *catch-fish-normal-sg*
  catch-fisha
  catch-fisha-lod0-jg
  catch-fisha-idle-ja
  ((catch-fisha-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
)

(defskelgroup *catch-fish-big-sg*
  catch-fishb
  catch-fishb-lod0-jg
  catch-fishb-idle-ja
  ((catch-fishb-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
)

(defskelgroup *catch-fish-deadly-sg*
  catch-fishc
  catch-fishc-lod0-jg
  catch-fishc-idle-ja
  ((catch-fishc-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
)

(defskelgroup *fish-net-sg*
  fish-net
  fish-net-lod0-jg
  fish-net-fishing-ja
  ((fish-net-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4)
)

(defskelgroup *fisher-sg*
  fisher
  fisher-lod0-jg
  fisher-idle-more-often-ja
  ((fisher-lod0-mg (meters 20)) (fisher-lod1-mg (meters 40)) (fisher-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 -6 0 14)
  :shadow fisher-shadow-mg
)

(defmethod process-taskable-method-52 ((this fisher))
  (let ((shadow-ctrl (-> this draw shadow-ctrl)))
    (when shadow-ctrl
      (let ((height (-> this root trans y)))
        (set! (-> shadow-ctrl settings bot-plane w) (- (- height (meters 0.25))))
        (set! (-> shadow-ctrl settings top-plane w) (- (+ height (meters 1.0))))
      )
      
      (logclear! (-> shadow-ctrl settings flags) (shadow-flags shdf03))
    )
  )

  (none)
)

(defmethod draw-npc-shadow ((this fisher))
  (cond
    ((and
          (-> this draw shadow)
          (zero? (-> this draw cur-lod))
          (logtest? (-> this draw status) (draw-status was-drawn))
        )
      (logclear! (-> (-> this draw shadow-ctrl) settings flags) (shadow-flags disable-draw))
      (update-direction-from-time-of-day (-> this draw shadow-ctrl))
    )
    (else
      (logior! (-> (-> this draw shadow-ctrl) settings flags) (shadow-flags disable-draw))
    )
  )

  (none)
)

(defbehavior fisher-parent fisher-fish ()
  (the-as fisher (-> self parent 0))
)

(defbehavior fisher-fish-water fisher-fish ((pos vector) (rot float))
  (let ((part-pos (new 'stack-no-clear 'vector)))
    (set! (-> part-pos quad) (-> pos quad))
    (set! (-> part-pos y) (ocean-get-height part-pos))
    (set! (-> *part-id-table* 118 init-specs 4 initial-valuef) (+ (degrees 135.0) rot)) ; rot-y
    (set! (-> *part-id-table* 118 init-specs 19 initial-valuef) (+ (degrees 270.0) rot)) ; rotate-y
    (set! (-> *part-id-table* 118 init-specs 1 initial-valuef) 0.05) ; num
    (set! (-> *part-id-table* 118 init-specs 2 initial-valuef) 0.0) ; x
    (set! (-> *part-id-table* 118 init-specs 13 initial-valuef) 0.35555556) ; fade-a
    (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 118) part-pos)
  )

  (none)
)

(defbehavior fisher-fish-move fisher-fish ()
  (+! (-> self pos) (per-second (-> self vel)))

  ; Update position from path
  (eval-path-curve-div! (-> (fisher-parent) path) (-> self root trans) (-> self pos) 'interp)
  (eval-path-curve-angle (-> (fisher-parent) path) (-> self dir) (-> self pos))
  (seek-toward-heading-vec! (-> self root) (-> self dir) (degrees 1600.0) (seconds 0.2))

  ; Apply offset in river
  (let (
        (angle (+ (degrees 90.0) (y-angle (-> self root))))
        (offset-from-center (* 2.0 (- (-> self offset) 0.5)))
        (river-offset (new-stack-vector0))
      )
    (set-vector! river-offset (sin angle) 0.0 (cos angle) 1.0 ) ; offset perpendicular to where we're facing
    (vector-normalize! river-offset (* offset-from-center (-> *fisher-bank* width)))
    (vector+! (-> self root trans) (-> self root trans) river-offset)
  )

  ; Spawn some water particles on the way
  (fisher-fish-water (-> self root trans) (y-angle (-> self root)))
  (if (nonzero? (-> self part))
    (spawn (-> self part) (-> self root trans))
  )

  (none)
)

(defstate fisher-fish-fall (fisher-fish)
  :code
    (behavior ()
      (set-heading-vec!
        (-> self root)
        (eval-path-curve-angle (-> (fisher-parent) path) (-> self dir) (-> self pos))
      )

      (loop
        (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (fisher-fish-move)

          (if (<
                (vector-vector-xz-distance (-> self root trans) (-> (fisher-parent) paddle-pos))
                (+ (-> *fisher-bank* net-radius) (* (-> self size) (-> self root scale x)))
              )
            (go fisher-fish-caught)
          )

          (if (or
                (>= (-> self pos) (- (-> (fisher-parent) path curve num-cverts) 1))
                (>= (-> self pos) (res-lump-float (-> (fisher-parent) entity) 'miss-fish-at :default 7.2))
              )
            (go fisher-fish-die)
          )

          (suspend)
          (ja :num! (seek!))
        )
      )
    )
  :post ja-post
)

(defstate fisher-fish-caught (fisher-fish)
  :code
    (behavior ()
      (case (-> self fish-type)
        (('deadly)
          (sound-play "caught-eel")
          (ambient-hint-spawn "sksp0a42" (-> self root trans) *entity-pool* 'ambient)
          (send-event (ppointer->process (-> self parent)) 'deadly)
        )
        (('big)
          (process-spawn part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 179)
            -1
            #f
            #f
            #f
            (-> self root trans)
            :to *entity-pool*
          )
          (sound-play "get-big-fish")
          (send-event (ppointer->process (-> self parent)) 'fisher-fish-caught 5)
        )
        ;;[ADD-FISH-TYPE] Add handling for fish being caught here
        (else
          (process-spawn part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 179)
            -1
            #f
            #f
            #f
            (-> self root trans)
            :to *entity-pool*
          )
          (sound-play "get-small-fish")
          (send-event (ppointer->process (-> self parent)) 'fisher-fish-caught 1)
        )
      )

      (/! (-> self vel) 4) ; Make them move less but don't just kill their velocity
      (while (< 0.1 (-> self root scale x))
        (set! (-> self offset) (-> (fisher-parent) paddle))
        (fisher-fish-move)
        (vector-float*! (-> self root scale) (-> self root scale) 0.93)
        (ja-post)
        (suspend)
        (ja :num! (loop!))
      )
    )
)

(defstate fisher-fish-die (fisher-fish)
  :code (behavior ()
    (case (-> self fish-type)
      (('deadly))
      (('big)
        (level-hint-spawn (text-id sidekick-hint-fish-powerup) "sksp0b42" (the-as entity #f) *entity-pool* (game-task none))
        (let ((ambient-rng (rand-float-gen)))
          (if (< 0.5 ambient-rng)
            (play-ambient (-> (fisher-parent) ambient) "FIS-TA04" #t (-> self root trans))
            (play-ambient (-> (fisher-parent) ambient) "FIS-TA05" #t (-> self root trans))
          )
        )
        (send-event (ppointer->process (-> self parent)) 'fisher-fish-die 5)
      )
      ;;[ADD-FISH-TYPE] Add handling for fish being missed here
      (else
        (let ((ambient-rng (rand-float-gen)))
          (cond
            ((< 0.8333 ambient-rng)
              (if (< (-> (fisher-parent) paddle-pos z) (-> self root trans z))
                (play-ambient (-> (fisher-parent) ambient) "FIS-TA01" #t (-> self root trans))
                (play-ambient (-> (fisher-parent) ambient) "FIS-TA02" #t (-> self root trans))
              )
            )
            ((< 0.6666 ambient-rng)
              (if (< (-> (fisher-parent) paddle-pos z) (-> self root trans z))
                (play-ambient (-> (fisher-parent) ambient) "FIS-TA1A" #t (-> self root trans))
                (play-ambient (-> (fisher-parent) ambient) "FIS-TA2A" #t (-> self root trans))
              )
            )
            ((< 0.5 ambient-rng)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA06" #t (-> self root trans))
            )
            ((< 0.3333 ambient-rng)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA08" #t (-> self root trans))
            )
            ((< 0.1666 ambient-rng)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA09" #t (-> self root trans))
            )
            ((> (-> (fisher-parent) missed) 0)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA10" #t (-> self root trans))
            )
          )
        )
        (send-event (ppointer->process (-> self parent)) 'fisher-fish-die 1)
      )
    )
  )
)

(defbehavior fisher-fish-init-by-other fisher-fish ((type symbol) (offset float) (vel float))
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self size) (meters 0.8))

  (initialize-skeleton self
    (cond
      ((= type 'deadly)
        (set! (-> self size) (meters 0.1))
        (set-vector! (-> self root scale) 0.9 0.9 0.7 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 177) self))
        *catch-fish-deadly-sg*
      )
      ((= type 'big)
        (set-vector! (-> self root scale) 0.4 0.4 0.4 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 178) self))
        *catch-fish-big-sg*
      )
      ;;[ADD-FISH-TYPE] Add initialization here
      (else
        (set-vector! (-> self root scale) 0.3 0.3 0.3 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 178) self))
        *catch-fish-normal-sg*
      )
    )
    '()
  )

  (set! (-> self fish-type) type)
  (set! (-> self pos) 1.0)
  (set! (-> self offset) offset)
  (set! (-> self vel) vel)
  (set! (-> self draw force-lod) 0)
  (set! (-> self root transv z) (meters 10.0))
  (set-vector! (-> self draw color-mult) 0.6 0.6 0.6 1.0)
  (set-vector! (-> self draw color-emissive) 0.6 0.6 0.6 0.0)

  (go fisher-fish-fall)

  (none)
)

(defbehavior fisher-get-perm fisher ()
  (the-as fisher-perm (-> self entity extra perm))
)

(defbehavior fisher-draw-display-pair fisher ((ctx font-context) (text string) (num int))
  (let (
        (text-x 435.0)
        (num-x  488.0)
      )
    (format (clear *temp-string*) "~3D" num)

    (set! (-> ctx origin x) text-x)
    (print-game-text text ctx #f 128 22)

    (set! (-> ctx origin x) num-x)
    (print-game-text *temp-string* ctx #f 128 22)
  )
)

(defbehavior fisher-draw-display-progress fisher ((ctx font-context) (text string) (progress int) (max int))
  (let (
        (text-x 435.0)
        (progress-x (if (< max 10) 468.0 458.0))
        (slash-x (if (< max 10) 478.0 468.0))
        (max-x 488.0)
      )

    (set! (-> ctx origin x) text-x)
    (print-game-text text ctx #f 128 22)

    (set! (-> ctx origin x) progress-x)
    (format (clear *temp-string*) (if (< max 10) "~1D" "~2D") progress)
    (print-game-text *temp-string* ctx #f 128 22)

    (set! (-> ctx origin x) slash-x)
    (print-game-text "/" ctx #f 128 22)

    (set! (-> ctx origin x) max-x)
    (format (clear *temp-string*) (if (< max 10) "~1D" "~2D") max)
    (print-game-text *temp-string* ctx #f 128 22)
  )
)

(defbehavior fisher-draw-display fisher ((this fisher))
  (let* (
        (start-x 435)
        (start-y  10)
        (line-height 15.0)
        (ctx (new 'stack 'font-context *font-default-matrix* start-x start-y 0.0 (font-color red) (font-flags shadow kerning)))
      )
    (set! (-> ctx width) 200.0)
    (set! (-> ctx height) 30.0)
    (set! (-> ctx scale) 0.7)
    (set! (-> ctx flags) (font-flags shadow kerning right large))

    (fisher-draw-display-pair ctx
      (lookup-text! *common-text* (text-id caught) #f)
      (-> this caught)
    )
    (+! (-> ctx origin y) line-height)

    (fisher-draw-display-pair ctx
      (lookup-text! *common-text* (text-id missed) #f)
      (-> this missed)
    )
    (+! (-> ctx origin y) line-height) ; re-used only if Extra HUD is on

    ; Extra HUD displays:
    ; - Wave: XX/YY
    ; - Pity:   XXX
    (when (-> *pc-settings* extra-hud?)
      (fisher-draw-display-progress ctx
        (lookup-text! *common-text* (text-id wave) #f)
        (max 1 (-> this wave)) ; Avoid displaying the initial 2 seconds of wait time as Wave 0
        (-> *fisher-wave-counts* (-> this pity))
      )
      (+! (-> ctx origin y) line-height)

      ; Only render pity if not in hard mode (since hard mode uses pity=5) (which tbh would be really funny but no)
      (when (not (-> this hard))
        (fisher-draw-display-pair ctx
          (lookup-text! *common-text* (text-id pity) #f)
          (-> this pity)
        )
      )
    )
  )

  (none)
)

(defmethod play-anim! ((this fisher) (arg0 symbol))
  (if arg0
    (set! (-> this training) #f)
  )

  (case (current-status (-> this tasks))
    (((task-status need-hint) (task-status need-introduction))
      (when arg0
        (set! (-> this blend-on-exit) (the-as art-joint-anim #t))
        (close-status! (-> this tasks) (task-status need-introduction))
        (set! (-> this training) #t)
      )
      (new 'static 'spool-anim
        :name "fisher-introduction"
        :index 8
        :parts 9
        :command-list '(
          (0 want-levels village1 jungle)
          (0 alive "jungle-part-1")
          (130 blackout 10)
          (130 display-level village1 movie)
          (130 want-force-vis village1 #t)
          (134 blackout 0)
          (229 blackout 10)
          (232 blackout 0)
          (235 display-level village1 #f)
          (235 want-force-vis village1 #f)
          (419 blackout 10)
          (422 blackout 0)
          (518 blackout 10)
          (521 blackout 0)
          (585 blackout 10)
          (588 blackout 0)
          (668 blackout 10)
          (671 blackout 0)
          (848 display-level village1 movie)
          (848 want-force-vis village1 #t)
          (849 alive "fishermans-boat-2")
          (878 blackout 10)
          (881 blackout 0)
          (958 blackout 10)
          (961 blackout 0)
          (965 dead "fishermans-boat-2")
          (965 display-level village1 display)
          (965 want-force-vis village1 #f)
        )
      )
    )
    (((task-status need-reminder-a) (task-status need-reminder))
      (set! (-> this skippable) #t)
      (set! (-> this blend-on-exit) (the-as art-joint-anim #t))
      (new 'static 'spool-anim
        :name "fisher-reminder-1"
        :index 10
        :parts 1
        :command-list '()
      )
    )
    (((task-status need-reward-speech))
      (when arg0
        (set! (-> this cell-for-task) (current-task (-> this tasks)))
        (close-current! (-> this tasks))
      )
      (new 'static 'spool-anim
        :name "fisher-resolution"
        :index 9
        :parts 4
        :command-list '(
          (188 blackout 10)
          (199 blackout 0)
        )
      )
    )
    (else
      (if arg0
        (format 0
          "ERROR: <GMJ>: ~S playing anim for task status ~S~%"
          (-> this name)
          (task-status->string (current-status (-> this tasks)))
        )
      )

      (get-art-elem this)
    )
  )
)

(defmethod get-art-elem ((this fisher))
  (if (closed? (-> this tasks) (game-task jungle-fishgame) (task-status need-reminder))
    (-> this draw art-group data 7)
    (-> this draw art-group data 6)))

(defmethod process-taskable-method-38 ((this fisher))
  (case (current-status (-> this tasks))
    (((task-status need-reminder-a) (task-status need-reminder)) (go (method-of-object this query)))
    (((task-status need-reward-speech)) (go (method-of-object this play-anim)))
    (else (call-parent-method this)))
  (none))

(defmethod get-accept-anim ((this fisher) (arg0 symbol))
  (when arg0
    (close-current! (-> this tasks))
    (aybabtu 2)
  )

  (new 'static 'spool-anim
    :name "fisher-accept"
    :index 12
    :parts 6
    :command-list '(
      (0 send-event self emissive-on)
      (700 send-event self emissive-off)
    )
  )
)

(defmethod get-reject-anim ((this fisher) (arg0 symbol))
  (new 'static 'spool-anim
    :name "fisher-reject"
    :index 11
    :parts 2
    :command-list '()
  )
)

(defstate fisher-done (fisher)
  :enter
    (behavior ()
      (init! (-> self query)
        (lookup-text! *common-text* (text-id play-again?) #f)
        40 150
        30
        #f
        (lookup-text! *common-text* (text-id quit) #f)
      )

      (ja-channel-set! 1)
      (ja :group! (get-art-elem self))
      (set-time! (-> self state-time))

      (while (-> self child)
        (deactivate (-> self child 0))
      )

      (set! *camera-look-through-other* 2)

      (cond
        ; If we succeeded
        ((>= (-> self caught) (-> self max-caught))
          (send-event *target* 'end-mode)
          (set! (-> self trans-hook)
            (lambda :behavior fisher ()
              (set! *camera-look-through-other* 2)
              (when (process-grab? *target*)
                (close-current! (-> self tasks))
                (go-virtual play-anim)
              )
              (none)
            )
          )
        )

        ; If we failed
        (else
          (let ((perm (fisher-get-perm)))
            (logior! (-> perm status) (entity-perm-status user-set-from-cstage))

            ; Increase accum
            (cond
              ((-> self hard))
              ((and (< (-> self caught) 40) (< (-> self missed) 5)))
              ((and (< (-> self caught) 80) (< (-> self missed) 10)))
              (else
                (+! (-> perm div) 1)
                (let ((caught (-> self caught)))
                  (if (>= caught 90)
                    (+! caught (- caught -90))
                  )
                  (+! (-> perm accum) (* 12.903226 (/ (the float caught) (fmax 5.0 (the float (-> self missed))))))
                )
              )
            )

            ; Increase pity
            (let ((f0-4 (if (zero? (-> perm div)) 200.0 (/ (-> perm accum) (-> perm div)))))
              (when (zero? (mod (+ (-> perm attempts) 1) (the-as uint 5))) ; Only every 5 attempts
                (cond
                  ((-> self hard)) ; We're in hard mode, we have no pity.
                  ((= (-> perm attempts) 4) ; just lost attempt 4
                    (if (< f0-4 60.0)
                      (set! (-> perm pity)
                        (seekl (the-as int (-> perm pity)) *fisher-max-pity* 1)
                      )
                    )
                    (set! (-> perm accum) 0.0)
                    (set! (-> perm div) 0)
                    0)
                  ((= (-> perm attempts) 9) ; just lost attempt 9
                    (if (< f0-4 120.0)
                      (set! (-> perm pity)
                        (seekl (the-as int (-> perm pity)) *fisher-max-pity* 1)
                      )
                    )
                  )
                  (else ; just lost attempts 14, 19, and so on
                    (set! (-> perm pity)
                      (seekl (the-as int (-> perm pity)) *fisher-max-pity* 1)
                    )
                  )
                )
              )
            )

            ; increment attempts, up to 255 to fit within the 8 bits we get
            (set! (-> perm attempts) (seekl (the-as int (-> perm attempts)) 255 1))

            ; update pity
            (set! (-> self pity) (the-as int (-> perm pity)))
            (if (-> self hard) (set! (-> self pity) *fisher-hardmode-idx*))
            
            (format #t
              "fisher: accum ~f  div ~d  tries ~d  diff ~d~%"
              (-> perm accum) (-> perm div) (-> perm attempts) (-> perm pity)
            )
          )

          (process-spawn-function process
            (lambda :behavior process ()
              (suspend-for (seconds 0.1))
              (ambient-hint-spawn "st-lose" (the-as vector #f) *entity-pool* 'stinger)
              (none)
            )
          )

          (send-event *target* 'lose)
        )
      )
    )

  :exit
    (behavior ()
      (when (and *target* (the-as target #f))
        (send-event *target* 'end-mode)
        (process-grab? *target*)
      )
    )

  :trans
    (behavior ()
      (set! *camera-look-through-other* 2)

      (cond
        ((>= (-> self caught) (-> self max-caught)))
        ((< (-> self caught) 0))
        (else
          (when (< (mod (-> *display* base-frame-counter) (seconds 1)) (seconds 0.5))
            ;; og:preserve-this PAL patch here
            (let ((ctx (new 'stack 'font-context *font-default-matrix* 56 100 0.0 (font-color red) (font-flags shadow kerning))))
              (set! (-> ctx width) 400.0)
              (set! (-> ctx height) 50.0)
              (set! (-> ctx flags) (font-flags shadow kerning middle large))
              (print-game-text (lookup-text! *common-text* (text-id lose!) #f) ctx #f 128 22)
            )
          )
          (fisher-draw-display self)

          (let ((response (get-response (-> self query))))
            (cond
              ((and (= response 'yes) (process-release? *target*))
                (go-virtual enter-playing)
              )
              ((= response 'no)
                (go-virtual play-reject)
              )
            )
          )
        )
      )

      (spool-push *art-control* "fisher-reject" 0 self -99.0)
    )

  :code process-taskable-anim-loop
  :post ja-post
)

(defbehavior fisher-spawn-ambient fisher ()
  (let ((ambient-rng (rand-float-gen)))
    (cond
      ((and
            (< 0.3 ambient-rng)
            (< (- (-> self max-caught) 30) (-> self caught))
          )
        (if (and
              (time-elapsed? (-> self ambient-almost) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA11" #t (-> self root trans))
            )
          (set-time! (-> self ambient-almost))
        )
      )
      ((< 0.125 ambient-rng))
      ((< 0.1 ambient-rng)
        (if (and
              (time-elapsed? (-> self ambient-steady) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA06" #t (-> self root trans))
            )
          (set-time! (-> self ambient-steady))
        )
      )
      ((< (- (-> self max-missed) 6) (-> self missed))
        (if (and
              (time-elapsed? (-> self ambient-sagging) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA07" #t (-> self root trans))
            )
          (set-time! (-> self ambient-sagging))
        )
      )
    )
  )

  (none)
)

(defbehavior fisher-game-update fisher ()
  ; Try to start next wave
  (when (time-elapsed? (-> self wave-time) (+ (-> self wave-data length) (-> self wave-data post-margin)))
    (set-time! (-> self wave-time))
    (+! (-> self wave) 1)
    (mem-copy!
      (the-as pointer (-> self wave-data))
      (the-as pointer (-> *fisher-waves* (-> self pity) (-> self wave)))
      (asize-of fisher-wave-data)
    )
  )

  ;mod: Since we introduced post-margin to waves, avoid spawning fish in-between waves
  (when (not (time-elapsed? (-> self wave-time) (-> self wave-data length)))
    (when (time-elapsed? (-> self turn-time) (-> self swing-time))
      (set-time! (-> self turn-time))
      (set! (-> self swing-time)
        (rand-vu-int-range
          (the-as int (-> self wave-data swing-min))
          (the-as int (-> self wave-data swing-max))
        )
      )
      (set! (-> self wave-data vel) (- (-> self wave-data vel)))
    )
    (+! (-> self spawner) (* (-> self wave-data vel) (seconds-per-frame)))

    ; Weird way for Pity 4 to give you lines of fish
    (if (= (-> self wave-data swing-min) 99999)
      (set! (-> self spawner) (* 0.01 (the float (-> self wave-data swing-max))))
    )

    ; Clamp the spawner pos
    (cond
      ((and
            (< 0.0 (-> self wave-data vel))
            (>= (-> self spawner) 1.0)
          )
        (set! (-> self wave-data vel) (- (-> self wave-data vel)))
        (set! (-> self spawner) 1.0)
      )
      ((and
            (> 0.0 (-> self wave-data vel))
            (<= (-> self spawner) 0.0)
          )
        (set! (-> self wave-data vel) (- (-> self wave-data vel)))
        (set! (-> self spawner) 0.0)
      )
    )

    ; Try to spawn a fish
    (when (and (nonzero? (-> self wave-data period)) (time-elapsed? (-> self spawn-time) (-> self wave-data period)))
      ;mod: Revamped fish type rng code, chances in waves were adjusted to match vanilla rates
      (let (
            (fish-type 'normal)
            (fish-rng (rand-float-gen))
            (sum 0.0)
            (fish-vel-mul (res-lump-float (-> self entity) 'fish-vel :default (-> *fisher-bank* fish-vel)))
          )
        (+! sum (-> self wave-data big-chance))
        (when (and (= fish-type 'normal) (< fish-rng sum))
          (if (and
                (time-elapsed? (-> self ambient-big-one) (seconds 30))
                (play-ambient (-> self ambient) "FIS-TA03" #t (-> self root trans))
              )
            (set-time! (-> self ambient-big-one))
          )

          (set! fish-type 'big)
        )

        (+! sum (-> self wave-data deadly-chance))
        (when (and (= fish-type 'normal) (< fish-rng sum))
          (set! fish-type 'deadly)
        )

        ;;[ADD-FISH-TYPE]
        ;;(+! sum (-> self wave-data <FISH-TYPE>-chance))
        ;;(when (and (= fish-type 'normal) (< fish-rng sum))
        ;;  (set! fish-type '<FISH-TYPE>)
        ;;)

        (if (and
              (!= fish-type 'deadly)
              (< 0.8 (fdelta (-> self spawner-last) (-> self spawner)))
            )
          (set! (-> self spawner) (* 0.5 (+ (-> self spawner-last) (-> self spawner))))
        )
        (set! (-> self spawner-last) (-> self spawner))
        (set-time! (-> self spawn-time))

        (sound-play "fish-spawn" :vol 70)
        (fisher-spawn-ambient)
        (process-spawn fisher-fish
          fish-type
          (-> self spawner)
          (* fish-vel-mul (-> self wave-data fish-vel))
          :to self
        )
      )
    )
  )

  ; Net control:
  ; 1. Accelerate
  ; 2. Decelerate (even if accelerated)
  ; 3. Clamp Velocity
  ; 4. Apply Velocity
  ; 5. Clamp Position%
  ; 6. Set Position to Position% between start and end points

  (let* ((net-accel (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 32.0 110.0 (-> *fisher-bank* net-accel))))
    (+! (-> self paddle-vel) (per-second net-accel))
  )
  (seek! (-> self paddle-vel) 0.0 (per-second (-> *fisher-bank* net-decel)))
  (fminmax! (-> self paddle-vel) (- (-> *fisher-bank* net-max-vel)) (-> *fisher-bank* net-max-vel))
  (+! (-> self paddle) (per-second (-> self paddle-vel)))
  (fminmax! (-> self paddle) 0.0 1.0)
  (vector-lerp! (-> self paddle-pos) (-> self paddle-end 0) (-> self paddle-end 1) (-> self paddle))

  (none)
)

(defstate fisher-playing (fisher)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))

      (case message
        (('fisher-fish-die)
          (sound-play "fish-miss")
          (+! (-> self missed) (the-as int (-> block param 0)))
          (the-as object (-> self missed))
        )
        (('fisher-fish-caught)
          (send-event *target* 'bounce)
          (+! (-> self caught) (the-as int (-> block param 0)))
          (the-as object (-> self caught))
        )
        (('deadly)
          (go fisher-done)
        )
      )
    )
  :enter
    (behavior ()
      (set-setting! 'ambient-volume 'rel 50.0 0)
      (send-event *target* 'reset-pickup 'eco)
      (ja-channel-set! 0)
      (clear-collide-with-as (-> self root))
      (process-spawn-function process
        (lambda :behavior fisher-fish ()
          (logclear! (-> self mask) (process-mask pause))
          (loop
            (fisher-draw-display (the-as fisher (ppointer->process (-> self parent))))
            (suspend)
          )
          (none)
        )
        :to self
      )
      (send-event *camera* 'change-to-entity-by-name "camera-152")
      (init! (-> self query)
        (the-as string #f)
        40 150
        25
        #t
        (lookup-text! *common-text* (text-id quit) #f)
      )
    )
  :exit
    (behavior ()
      (remove-setting! 'ambient-volume)
      (let* (
            (inv-cam-rot (-> *camera-combiner* inv-camera-rot))
            (icr-x (-> inv-cam-rot vector 0 quad))
            (icr-y (-> inv-cam-rot vector 1 quad))
            (icr-z (-> inv-cam-rot vector 2 quad))
            (icr-w (-> inv-cam-rot vector 3 quad))
          )
        (set! (-> *camera-other-matrix* vector 0 quad) icr-x)
        (set! (-> *camera-other-matrix* vector 1 quad) icr-y)
        (set! (-> *camera-other-matrix* vector 2 quad) icr-z)
        (set! (-> *camera-other-matrix* vector 3 quad) icr-w)
      )
      (set! (-> *camera-other-fov* data) (-> *camera-combiner* fov))
      (set! (-> *camera-other-trans* quad) (-> *camera-combiner* trans quad))
      (set! (-> *camera-other-root* quad) (-> self root trans quad))
      (restore-collide-with-as (-> self root))
      (send-event *camera* 'blend-from-as-fixed)
      (send-event *camera* 'change-state *camera-base-mode* 0)
      (send-event *camera* 'clear-entity)
      0
    )
  :trans
    (behavior ()
      (spool-push *art-control* "fisher-resolution" 0 self -99.0)
      (spool-push *art-control* "fisher-reject" 0 self -99.0)
    )
  :code
    (behavior ()
      (set! *display-profile* #f)

      (set! (-> self paddle) 0.5)
      (set! (-> self paddle-vel) 0.0)

      (set-time! (-> self start-time))

      (set! (-> self caught) 0)
      (set! (-> self missed) 0)

      (set! (-> self spawner) 0.5)
      (set! (-> self spawner-last) 0.5)

      (set! (-> self swing-time) 0)

      (set! (-> self wave) 0)
      (set-time! (-> self wave-time))
      (mem-copy!
        (the-as pointer (-> self wave-data))
        (the-as pointer (-> *fisher-waves* (-> self pity) (-> self wave)))
        (asize-of fisher-wave-data)
      )

      (set! (-> self ambient-big-one) 0)
      (set! (-> self ambient-steady) 0)
      (set! (-> self ambient-sagging) 0)
      (set! (-> self ambient-almost) 0)

      (loop
        (hide-hud-quick)
        (fisher-game-update)
        (if (or
              (zero? (-> self wave-data length))
              (>= (-> self missed) (-> self max-missed))
              (>= (-> self caught) (-> self max-caught))
            )
          (go fisher-done)
        )
        (suspend)
      )
    )
  :post
    (behavior ()
      (ja-post)
    )
)

(defstate enter-playing (fisher)
  :virtual #t
  :trans
    (behavior ()
      (set-blackout-frames (seconds 0.017))
      (if (send-event *target* 'change-mode 'fishing self)
        (go fisher-playing)
      )
    )
)

;; og:preserve-this pc port needs its own implementation of play-anim for cutscene skipping
(#when PC_PORT
  (define *fisher-camera-backup-fov* (degrees 46.2356))
  (define *fisher-camera-backup-trans* (static-vectorm 267.49615 3.8882813 -230.76254))
  (define *fisher-camera-backup-matrix*
    (new 'static 'matrix
      :vector (new 'static 'inline-array vector 4
          (new 'static 'vector :x -0.8677 :y -0.0000 :z 0.4969)
          (new 'static 'vector :x -0.0081 :y 0.9998 :z -0.0141)
          (new 'static 'vector :x -0.4968 :y -0.0163 :z -0.8676)
          (new 'static 'vector :w 1.0)
      )
    )
  )
  (define *fisher-camera-use-backup* #f)

  (defstate play-anim (fisher)
    :virtual #t
    :enter
      (behavior ()
        (set! *fisher-camera-use-backup* #f)
        ((-> (method-of-type process-taskable play-anim) enter))

        (none)
      )
    :exit
      (behavior ()
        (set! *fisher-camera-use-backup*
          (and
            (= (get-response (-> self query)) 'no)
            (or
              (not (= *cheat-mode* 'debug))
              (not (cpad-hold? 0 r1))
            )
            (-> self training)
          )
        )
        (set! (-> self cur-trans-hook)
          (lambda ()
            (when *fisher-camera-use-backup*
              (set! (-> *camera-other-fov* data) *fisher-camera-backup-fov*)
              (vector-copy! *camera-other-trans* *fisher-camera-backup-trans*)
              (matrix-copy! *camera-other-matrix* *fisher-camera-backup-matrix*)
            )

            (none)
          )
        )
        ((-> (method-of-type process-taskable play-anim) exit))

        (none)
      )
  )
)

(defstate query (fisher)
  :virtual #t
  :enter
    (behavior ()
      (init! (-> self query)
        (lookup-text! *common-text* (text-id fish?) #f)
        40 150
        25
        #f
        (lookup-text! *common-text* (text-id quit) #f)
      )
    )
  ;; og:preserve-this needed for cutscene skipping
  :exit
    (behavior ()
      (#when PC_PORT
        (set! (-> self cur-trans-hook) nothing)
      )
      ((-> (method-of-type process-taskable play-anim) exit))
    )
)

(defmethod do-idle-ambience ((this fisher))
  (cond
    ((closed? (-> this tasks) (game-task jungle-fishgame) (task-status need-reminder))
      (when (vector-for-ambient-limited (-> this ambient) (new 'stack-no-clear 'vector) (seconds 1) (meters 30.0) this)
        (let ((ambient-rng (rand-float-gen)))
          (if (< 0.5 ambient-rng)
            (play-ambient (-> this ambient) "FIS-LO03" #f (-> this root trans))
            (play-ambient (-> this ambient) "FIS-LO05" #f (-> this root trans))
          )
        )
      )
    )
    (else
      (when (vector-for-ambient-limited (-> this ambient) (new 'stack-no-clear 'vector) (seconds 30) (meters 30.0) this)
        (let ((ambient-rng (rand-float-gen)))
          (cond
            ((< 0.875 ambient-rng)
              (play-ambient (-> this ambient) "FIS-LO01" #f (-> this root trans))
            )
            ((< 0.75 ambient-rng)
              (play-ambient (-> this ambient) "FIS-LO04" #f (-> this root trans))
            )
            ((< 0.625 ambient-rng)
              (play-ambient (-> this ambient) "FIS-AM01" #f (-> this root trans))
            )
            ((< 0.5 ambient-rng)
              (play-ambient (-> this ambient) "FIS-AM02" #f (-> this root trans))
            )
            ((< 0.375 ambient-rng)
              (play-ambient (-> this ambient) "FIS-AM03" #f (-> this root trans))
            )
            ((< 0.25 ambient-rng)
              (play-ambient (-> this ambient) "FIS-AM04" #f (-> this root trans))
            )
            ((< 0.125 ambient-rng)
              (play-ambient (-> this ambient) "FIS-AM05" #f (-> this root trans))
            )
            (else
              (play-ambient (-> this ambient) "FIS-AM06" #f (-> this root trans))
            )
          )
        )
      )
    )
  )
)

(defstate play-accept (fisher)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('emissive-on)
          (set-vector! (-> self draw color-mult) 0.6 0.6 0.6 1.0)
          (set-vector! (-> self draw color-emissive) 0.6 0.6 0.6 0.0)
          (-> self draw color-emissive)
        )
        (('emissive-off)
          (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
          (set-vector! (-> self draw color-emissive) 0.0 0.0 0.0 0.0)
          (-> self draw color-emissive)
        )
      )
    )
  :trans
    (behavior ()
      (when (-> self training)
        (let ((gp-0 (new-stack-vector0)))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg mainA))
          (launch-particles (-> *part-id-table* 2001) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 75 bone transform vector 1))))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg mainB))
          (launch-particles (-> *part-id-table* 2001) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 78 bone transform vector 1))))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg top))
          (launch-particles (-> *part-id-table* 828) gp-0)
          (launch-particles (-> *part-id-table* 2013) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 80 bone transform vector 1))))
        )
      )

      (call-parent-state-handler trans)
    )
)

(defstate idle (fisher)
  :virtual #t
  :trans
    (behavior ()
      (call-parent-state-handler trans)
      (when (task-complete? *game-info* (-> (fisher-get-perm) task))
        (when (nonzero? (-> *cpad-list* cpads 0 button0-rel 0))
          ; Inputting hard mode cheat...
          (if (cpad-pressed-btn? 0 (-> *fisher-hardmode-cheat* (-> self cheat-progress)))
            (+! (-> self cheat-progress) 1)
            (set! (-> self cheat-progress) 0)
          )

          ; Successfully inputted hard mode cheat!
          (when (= (-> self cheat-progress) *fisher-hardmode-cheat-length*)
            ;mod: Add some extra changes so it's more obvious
            ; The music won't activate until the player goes away and comes back lol
            (sound-play "menu-close")
            (set! (-> self music) 'finalboss)

            (set! (-> self hard) #t)
            (set! (-> self pity) *fisher-hardmode-idx*)
            (set! (-> self max-caught) #x70000000)

            ;mod: this was a lil buggy and inconsistent so I commented it out
            ;(ambient-hint-spawn "FIS-LO03" (the-as vector #f) *entity-pool* 'stinger)

            (set! (-> self cheat-progress) 0)
          )
        )
      )
    )
  :code
    (behavior ()
      (if (!= (ja-group) (get-art-elem self))
        (ja-channel-push! 1 (seconds 0.2))
      )

      (loop
        (ja :group! (get-art-elem self))

        (let ((f30-0 5.0))
          (countdown (ignored (+ (the int (* f30-0 (rand-float-gen))) 5))
            (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (do-idle-ambience self)
              (suspend)
              (ja :num! (seek!))
            )
          )
        )

        (when (ja-group? fisher-idle-more-often-ja)
          (ja-no-eval :group! fisher-idle-less-often-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (do-idle-ambience self)
            (suspend)
            (ja :num! (seek!))
          )
        )
      )
    )
)

(defmethod initialize-collision ((this fisher) (arg0 int) (arg1 vector))
  (let ((cshape (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((group-fisher (new 'process 'collide-shape-prim-group cshape (the-as uint 2) 0)))
      (set! (-> group-fisher prim-core collide-as) (collide-kind enemy))
      (set! (-> group-fisher collide-with) (collide-kind target))
      (set! (-> group-fisher prim-core action) (collide-action solid))
      (set! (-> group-fisher prim-core offense) (collide-offense indestructible))
      (set-vector! (-> group-fisher local-sphere) (meters 1.5) 0.0 (meters 1.0) (meters 3.5))
      (set-root-prim! cshape group-fisher)

      (let ((sphere-fisher (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
        (set! (-> sphere-fisher prim-core collide-as) (collide-kind enemy))
        (set! (-> sphere-fisher collide-with) (collide-kind target))
        (set! (-> sphere-fisher prim-core action) (collide-action solid))
        (set! (-> sphere-fisher prim-core offense) (collide-offense indestructible))
        (set! (-> sphere-fisher transform-index) arg0)
        (set-vector! (-> sphere-fisher local-sphere) 0.0 0.0 0.0 (meters 1.6))
        (append-prim group-fisher sphere-fisher)
      )

      (let ((sphere-basket (new 'process 'collide-shape-prim-sphere cshape (the-as uint 0))))
        (set! (-> sphere-basket prim-core collide-as) (collide-kind enemy))
        (set! (-> sphere-basket collide-with) (collide-kind target))
        (set! (-> sphere-basket prim-core action) (collide-action solid))
        (set! (-> sphere-basket prim-core offense) (collide-offense indestructible))
        (set! (-> sphere-basket transform-index) 57)
        (set-vector! (-> sphere-basket local-sphere) 0.0 (meters 1.0) 0.0 (meters 2.0))
        (append-prim group-fisher sphere-basket)
      )
    )

    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (backup-collide-with-as cshape)
    (set! (-> this root) cshape)
  )

  (none)
)

(defmethod target-above-threshold? ((this fisher))
  (or
    (= (current-task (-> this tasks)) (game-task jungle-fishgame))
    (-> this hard)
  )
)

(defmethod init-from-entity! ((this fisher) (arg0 entity-actor))
  (process-taskable-method-40 this arg0 *fisher-sg* 3 49 (new 'static 'vector :w (meters 1.0)) 33)

  (set! (-> this tasks) (get-task-control (game-task jungle-fishgame)))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))

  ; Initialize the net/paddle limits
  (let* (
        (river-end-t (res-lump-float (-> this entity) 'river-end-at :default 6.5))
        (river-end (eval-path-curve-div! (-> this path) (-> this paddle-pos) river-end-t 'interp))
        (river-end-angled (eval-path-curve-angle (-> this path) (new-stack-vector0) river-end-t))
      )
    (+! (-> river-end y) (meters 0.6))
    (vector-normalize! (vector-rotate-y! river-end-angled river-end-angled (degrees 90.0)) (-> *fisher-bank* width))
    (vector-! (-> this paddle-end 0) river-end river-end-angled)
    (vector+! (-> this paddle-end 1) river-end river-end-angled)
  )

  (set! (-> this music) 'fishgame)
  (set! (-> this pity) (the-as int (-> (fisher-get-perm) pity)))
  (set! (-> this hard) #f)
  (set! (-> this max-caught) (res-lump-value (-> this entity) 'max-caught int :default (the uint128 (-> *fisher-bank* max-caught))))
  (set! (-> this max-missed) (res-lump-value (-> this entity) 'max-missed int :default (the uint128 (-> *fisher-bank* max-missed))))
  (set! (-> this training) #f)

  (process-taskable-method-42 this)

  (none)
)

(defstate target-fishing (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (cond
        ((= message 'bounce)
         (set-zero! (-> self control unknown-smush00))
         (activate! (-> self control unknown-smush00) 1.0 120 210 0.3 1.0))
        ((= message 'lose)
          (set! (-> self control unknown-uint20) (the-as uint message))
          message
        )
        (else
          ((-> target-grab event) proc argc message block)
        )
      )
    )
  :enter
    (behavior ((arg0 handle))
      (set! (-> self control unknown-surface00) *empty-mods*)
      (logior! (-> self state-flags) (state-flags invulnerable))
      (set-zero! (-> self control unknown-smush00))
      (set! (-> self control unknown-uint20) (the-as uint #f))
    )
  :exit
    (behavior ()
      (logclear! (-> self state-flags) (state-flags invulnerable))
      (let ((v1-2 (-> self manipy)))
        (when v1-2
          (deactivate (-> v1-2 0))
          (set! (-> self manipy) (the-as (pointer manipy) #f))
        )
      )
      (-> target-periscope exit)
    )
  :code
    (behavior ((fisher-handle handle))
      (let ((fisherman (handle->process fisher-handle)))
        (when (and fisherman (type-type? (-> fisherman type) fisher))
          (set-vector! (-> self control trans) (meters 260.7) (meters 2.3) (meters -233.3) 1.0)
          (set-yaw-angle-clear-roll-pitch! (-> self control) (degrees -110.0))
          (rot->dir-targ! (-> self control))
        )
      )

      (ja-channel-set! 1)

      (let ((s5-0 (get-process *default-dead-pool* manipy #x4000)))
        (set! (-> self manipy)
          (the-as (pointer manipy)
            (when s5-0
              (let ((t9-5 (method-of-type manipy activate)))
                (t9-5 (the-as manipy s5-0) self 'manipy (the-as pointer #x70004000))
              )

              (let ((fisherman (handle->process fisher-handle)))
                (run-function-in-process
                  s5-0
                  manipy-init
                  (-> self control trans)
                  (if fisherman (-> fisherman entity) (the-as entity-actor #f))
                  *fish-net-sg*
                  #f
                  #f #f
                )
              )

              (-> s5-0 ppointer)
            )
          )
        )
      )

      (when (-> self manipy)
        (send-event (ppointer->process (-> self manipy)) 'anim-mode 'copy-parent)
        (send-event
          (ppointer->process (-> self manipy))
          'eval
          (lambda :behavior manipy ()
            (set! (-> self joint 0) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) self 6))
            (set! (-> self joint 1) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) self 5))
            (none)
          )
        )
        (let ((v1-35 (-> self manipy 0 node-list data)))
          (set! (-> v1-35 0 param0) cspace<-cspace+quaternion!)
          (set! (-> v1-35 0 param1) (the-as basic (joint-node eichar-lod0-jg sk_rhand)))
          (set! (-> v1-35 0 param2) (the-as basic (-> self control quat)))
        )
      )
      (ja :group! eichar-fishing-ja :num! (identity (ja-aframe 15.0 0)))
      (let ((s5-2 (new 'stack-no-clear 'vector)))
        (until (-> self control unknown-spoolanim00)
          (let ((fisherman (handle->process fisher-handle)))
            (when fisherman
              (ja
                :num! (seek!
                  (*
                    (fmax 0.0 (- 1.0 (-> (the-as fisher fisherman) paddle)))
                    (the float (+ (-> (ja-group) data 0 length) -1))
                  )
                )
              )

              (when (-> self manipy)
                (let (
                      (s2-0 (new-stack-vector0))
                      (s4-0 (new-stack-vector0))
                      (s3-0 (quaternion-identity! (new-stack-quaternion0)))
                      (f30-0 (update! (-> self control unknown-smush00)))
                    )
                  (quaternion-rotate-y! s3-0 s3-0 (* (degrees 30.0) f30-0))
                  (set-vector! s2-0 1.0 1.0 1.0 1.0)
                  (set-vector! s4-0 0.0 (* (meters 0.5) (-> s5-2 y)) (* (meters 0.2) (-> s5-2 y)) 1.0)
                  (set-trs! (-> self manipy 0 joint 0) s4-0 s3-0 s2-0)
                  (set-vector! s4-0 0.0 (* (meters -0.15) f30-0) 0.0 1.0)
                  (set-trs! (-> self manipy 0 joint 1) s4-0 (the-as quaternion #f) (the-as vector #f))
                  (set! (-> s5-2 y) (-> s5-2 x))
                  (set! (-> s5-2 x) f30-0)
                )
              )
            )
          )

          (suspend)
        )
      )

      (case (-> self control unknown-spoolanim00)
        (('lose)
          (ja-channel-push! 1 (seconds 0.1))
          (ja-no-eval :group! eichar-fishing-lose-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
          )
          (anim-loop)
        )
      )
    )
  :post target-post)
